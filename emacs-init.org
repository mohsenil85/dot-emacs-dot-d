#+TITLE: My Special Emacs Configuration
#+AUTHOR: logan mohseni
#+EMAIL: mohsenil85@gmail.com 
#+OPTIONS: toc:3 num:nil ^:nil

I used `brew cask install emacs-mac` to get this version of emacs
* Load Custom file
this file is written to by m-x customize
#+BEGIN_SRC emacs-lisp
(require 'custom)
#+END_SRC 
* Packages
** Configure package archives
Use MELPA and the org archives. Put them first to avoid installed gnu
packages if there are newer ones from melpa available.

If we have a net connection, we'll refresh the package list on
startup.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.milkbox.net/packages/"))

  (add-to-list 'package-archives
               '("org" . "http://orgmode.org/elpa/"))

  (setq my-onlinep nil)
  (unless
      (condition-case nil
          (delete-process
           (make-network-process
            :name "my-check-internet"
            :host "melpa.milkbox.net"
            :service 80))
        (error t))
    (setq my-onlinep t))

(package-initialize)
;  (when my-onlinep
;    (package-refresh-contents)
;    (package-initialize))
#+END_SRC
** Setup use-package
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/vendor/use-package")
  (require 'use-package)
#+END_SRC
** Packages and their configuration
   To force a package to get installed if it isn't already available, add
   =:ensure=. To provide configuration you can use either =:init= or
   =:config=. The =:init= form runs even when package loading is
   deferred. The =:config= form *only* runs after the module has been
   loaded (so might be more appropriate for calling functions defined in
   the module, e.g.)
   
   There are helpers to =:bind= keys, setup =:mode= hooks, and modify
   =:load-path=.
   evil leader is required before evil
    #+BEGIN_SRC emacs-lisp
(use-package evil-leader
:ensure
:config
(progn
(global-evil-leader-mode 1)
(evil-leader/set-leader ",")))
    #+END_SRC
   main evil
    #+BEGIN_SRC emacs-lisp
    (use-package evil
      :ensure
      :config
      (evil-mode 1))
    #+END_SRC
*** tao theme
    #+BEGIN_SRC emacs-lisp
    (use-package basic-theme :ensure)
    (load-theme 'basic)

    #+END_SRC
*** TODO helm from tuhdo
*** yasnippets everywere 
*** page break lines
        #+BEGIN_SRC emacs-lisp
    (use-package page-break-lines
      :ensure
      :config
      (global-page-break-lines-mode))
    #+END_SRC

*** Various edit modes
    #+BEGIN_SRC emacs-lisp :tangle yes
(use-package ag :ensure)
(use-package markdown-mode :ensure)
;;(use-package paredit :ensure)
    #+END_SRC
*** org-mode 
    Since use-package detects the version of org that comes with Emacs, I
    ended up running an install from MELPA manually. I've also cloned the
    org git repo into the vendor dir to have access to the contribs.
    #+BEGIN_SRC emacs-lisp
(use-package org
  :ensure
  :mode ("\\.org$" . org-mode)
  :load-path "~/.emacs.d/vendor/org-mode/contrib/lisp"
  :bind (("C-c l" . org-store-link)
         ("C-c a" . org-agenda)
         ("C-c b" . org-iswitchb))
  :init
  (setq
   org-directory "~/org"
   org-mobile-inbox-for-pull "~/org/from-mobile.org"
   org-mobile-directory "~/Dropbox/MobileOrg"
   org-agenda-files (quote ("~/org/logan.org"))
   org-enforce-todo-dependencies t
   org-velocity-bucket "~/org/solutions.org"
   org-default-notes-file (concat org-directory "/notes.org")
   org-log-done t
   ;; this prevents org-mode from adding leading whitespace to code
   ;; blocks after editing
   org-src-preserve-indentation t)
  
  ;; where to refile
  (setq org-refile-targets
        '((nil . (:level . 1))
          ("solutions.org" . (:level . 1))
          ("seth.org" . (:level . 1))
          ("seth-sometime.org" . (:level . 1))
          ("seth-ref.org" . (:level . 1))))
  
  (setq org-refile-use-outline-path 'file)
  )

(use-package org-velocity
  :bind (("C-c 0" . org-velocity-read))
  )

(defun my/org-capture ()
  (interactive)
  (org-capture nil "j"))

(defun my/one-on-one ()
    (interactive)
    (with-temp-buffer
      (setq default-directory "~/Notebook/org/1:1")
      (call-interactively 'ido-find-file)
      (setq current-one-on-one (buffer-file-name))
      (org-capture nil "x")))

(defun my/meeting ()
    (interactive)
    (with-temp-buffer
      (setq default-directory "~/Notebook/org/meetings")
      (call-interactively 'ido-find-file)
      (setq current-one-on-one (buffer-file-name))
      (org-capture nil "m")))

(use-package org-capture
  :bind (("C-c 1" . my/org-capture)
         ("C-c 2" . my/one-on-one)
         ("C-c 3" . org-capture)
         ("C-c 4" . my/meeting)
         )
  :init
  (setq
   ;; capture setup
   org-capture-templates
   '(("t" "Todo" entry
      (file+headline (concat org-directory "/seth.org") "Next Action")
      "* TODO %?\n  %i\n  %a")
     ("s" "Solution" entry
      (file+headline (concat org-directory "/solutions.org"))
      "* %?\nEntered on %U\n  %i\n  %a")
     ("j" "Journal" entry
      (file (concat org-directory "/journal.org"))
      "* [%<%d-%b-%Y %H:%M>] %?\n%i\n")
     ("z" "Testing" entry
      (file (concat org-directory "/test-cap.org"))
      "* [%<%d-%b-%Y %H:%M>] %?\n%i\n")
     ("x" "1:1 Note" entry
      (file current-one-on-one)
      "* [%<%d-%b-%Y %H:%M>] %?\n%i\n" :prepend t :unnarrowed t)
     ("m" "Meeting Notes" entry
      (file current-meeting)
      "* [%<%d-%b-%Y %H:%M>] %?\n** Attendees\n** Notes%i\n" :prepend t :unnarrowed t)
     ("f" "Journal with file link" entry
      (file+datetree (concat org-directory "/journal.org"))
      "* [%<%H:%M>] %?\n%i\n%a\n")
     )
   )
  )

    #+END_SRC
    

* Defuns
Helper functions to use either in an editing session or to help with
configuration
#+BEGIN_SRC emacs-lisp
(require 'cl)

(defun save-init-org ()
(org-babel-load-file
 (expand-file-name "emacs-init.org"
                   user-emacs-directory)))

(defun add-hook-to-modes (modes hook)
  (dolist (mode modes)
    (add-hook (intern (concat (symbol-name mode) "-mode-hook"))
              hook)))

(defun halt ()
  (interactive)
  (save-some-buffers)
  (kill-emacs))

(defun my-whitespace-mode-hook ()
  (setq whitespace-action '(auto-cleanup)
        whitespace-style  '(face tabs trailing lines-tail empty)
        ;; use fill-column value instead
        whitespace-line-column nil)
  (whitespace-mode))

(defun my-makefile-mode-hook ()
  (setq indent-tabs-mode t
        tab-width 4))
#+END_SRC
** Prelude defuns and such
   #+BEGIN_SRC emacs-lisp
  ;;; prelude-core.el --- Emacs Prelude: core Prelude defuns.
  ;;
  ;; Copyright (c) 2011 Bozhidar Batsov
  ;;
  ;; Author: Bozhidar Batsov <bozhidar.batsov@gmail.com>
  ;; URL: http://www.emacswiki.org/cgi-bin/wiki/Prelude
  ;; Version: 1.0.0
  ;; Keywords: convenience

  ;; This file is not part of GNU Emacs.

  ;;; Commentary:

  ;; Here are the definitions of most of the functions added by Prelude.

  ;;; License:

  ;; This program is free software; you can redistribute it and/or
  ;; modify it under the terms of the GNU General Public License
  ;; as published by the Free Software Foundation; either version 3
  ;; of the License, or (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs; see the file COPYING.  If not, write to the
  ;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  ;; Boston, MA 02110-1301, USA.

  ;;; Code:

  (require 'thingatpt)

  (defun prelude-open-with ()
    "Simple function that allows us to open the underlying
  file of a buffer in an external program."
    (interactive)
    (when buffer-file-name
      (shell-command (concat
                      (if (eq system-type 'darwin)
                          "open"
                        (read-shell-command "Open current file with: "))
                      " "
                      buffer-file-name))))

  (defun prelude-buffer-mode (buffer-or-name)
    (with-current-buffer buffer-or-name major-mode))

  (defun prelude-visit-term-buffer ()
    (interactive)
    (if (not (get-buffer "*ansi-term*"))
        (ansi-term "/bin/bash")
      (switch-to-buffer "*ansi-term*")))

  (defun prelude-google ()
    "Googles a query or region if any."
    (interactive)
    (browse-url
     (concat
      "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
      (if mark-active
          (buffer-substring (region-beginning) (region-end))
        (read-string "Google: ")))))

  (defun prelude-indent-rigidly-and-copy-to-clipboard (begin end indent)
    "Copy the selected code region to the clipboard, indented according
  to Markdown blockquote rules."
    (let ((buffer (current-buffer)))
      (with-temp-buffer
        (insert-buffer-substring-no-properties buffer begin end)
        (indent-rigidly (point-min) (point-max) indent)
        (clipboard-kill-ring-save (point-min) (point-max)))))

  (defun prelude-indent-blockquote-and-copy-to-clipboard (begin end)
    "Copy the selected code region to the clipboard, indented according
  to markdown blockquote rules (useful to copy snippets to StackOverflow, Assembla, Github."
    (interactive "r")
    (prelude-indent-rigidly-and-copy-to-clipboard begin end 4))

  (defun prelude-indent-nested-blockquote-and-copy-to-clipboard (begin end)
    "Copy the selected code region to the clipboard, indented according
  to markdown blockquote rules. Useful to add snippets under bullet points."
    (interactive "r")
    (prelude-indent-rigidly-and-copy-to-clipboard begin end 6))

  (defun prelude-insert-empty-line ()
    "Insert an empty line after the current line and positon
  the curson at its beginning, according to the current mode."
    (interactive)
    (move-end-of-line nil)
    (open-line 1)
    (next-line 1)
    (indent-according-to-mode))

  ;; mimic popular IDEs binding, note that it doesn't work in a terminal session
  (global-set-key [(shift return)] 'prelude-insert-empty-line)

  (defun prelude-move-line-up ()
    "Move up the current line."
    (interactive)
    (transpose-lines 1)
    (previous-line 2))

  (global-set-key [(control shift up)] 'prelude-move-line-up)

  (defun prelude-move-line-down ()
    "Move down the current line."
    (interactive)
    (next-line 1)
    (transpose-lines 1)
    (previous-line 1))

  (global-set-key [(control shift down)] 'prelude-move-line-down)

  ;; add the ability to copy and cut the current line, without marking it
  (defadvice kill-ring-save (before slick-copy activate compile)
    "When called interactively with no active region, copy a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (message "Copied line")
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))

  (defun prelude-indent-buffer ()
    "Indents the entire buffer."
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun prelude-indent-region-or-buffer ()
    "Indents a region if selected, otherwise the whole buffer."
    (interactive)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end))
            (message "Indented selected region."))
        (progn
          (prelude-indent-buffer)
          (message "Indented buffer.")))))

  (defun prelude-annotate-todo ()
    "Put fringe marker on TODO: lines in the curent buffer."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "TODO:" nil t)
        (let ((overlay (make-overlay (- (point) 5) (point))))
          (overlay-put overlay
                       'before-string
                       (propertize (format "A")
                                   'display '(left-fringe right-triangle)))))))

  (defun prelude-copy-file-name-to-clipboard ()
    "Put the current file name on the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
                        default-directory
                      (buffer-file-name))))
      (when filename
        (with-temp-buffer
          (insert filename)
          (clipboard-kill-region (point-min) (point-max)))
        (message filename))))

  (defun prelude-duplicate-current-line-or-region (arg)
    "Duplicates the current line or region ARG times.
  If there's no region, the current line will be duplicated. However, if
  there's a region, all lines that region covers will be duplicated."
    (interactive "p")
    (let (beg end (origin (point)))
      (if (and mark-active (> (point) (mark)))
          (exchange-point-and-mark))
      (setq beg (line-beginning-position))
      (if mark-active
          (exchange-point-and-mark))
      (setq end (line-end-position))
      (let ((region (buffer-substring-no-properties beg end)))
        (dotimes (i arg)
          (goto-char end)
          (newline)
          (insert region)
          (setq end (point)))
        (goto-char (+ origin (* (length region) arg) arg)))))

  ;; TODO doesn't work with uniquify
  (defun prelude-rename-file-and-buffer ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (message "Buffer '%s' is not visiting a file!" name)
        (let ((new-name (read-file-name "New name: " filename)))
          (cond ((get-buffer new-name)
                 (message "A buffer named '%s' already exists!" new-name))
                (t
                 (rename-file name new-name 1)
                 (rename-buffer new-name)
                 (set-visited-file-name new-name)
                 (set-buffer-modified-p nil)))))))

  (defun prelude-delete-file-and-buffer ()
    "Kills the current buffer and deletes the file it is visiting"
    (interactive)
    (let ((filename (buffer-file-name)))
      (when filename
        (delete-file filename)
        (message "Deleted file %s" filename)))
    (kill-buffer))

  (defun prelude-view-url ()
    "Open a new buffer containing the contents of URL."
    (interactive)
    (let* ((default (thing-at-point-url-at-point))
           (url (read-from-minibuffer "URL: " default)))
      (switch-to-buffer (url-retrieve-synchronously url))
      (rename-buffer url t)
      ;; TODO: switch to nxml/nxhtml mode
      (cond ((search-forward "<?xml" nil t) (xml-mode))
            ((search-forward "<html" nil t) (html-mode)))))

  ;; We have a number of turn-on-* functions since it's advised that lambda
  ;; functions not go in hooks. Repeatedly evaluating an add-to-list with a
  ;; hook value will repeatedly add it since there's no way to ensure
  ;; that a lambda doesn't already exist in the list.

  (defun prelude-turn-on-whitespace ()
    (whitespace-mode +1))

  (defun prelude-turn-off-whitespace ()
    (whitespace-mode -1))

  (defun prelude-turn-on-abbrev ()
    (abbrev-mode +1))

  (defun prelude-turn-off-abbrev ()
    (abbrev-mode -1))

  (defun prelude-untabify-buffer ()
    (interactive)
    (untabify (point-min) (point-max)))

  (defun prelude-cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer."
    (interactive)
    (prelude-indent-buffer)
    (prelude-untabify-buffer)
    (whitespace-cleanup))

  (defun prelude-eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
        (prin1 (eval (read (current-kill 0)))
               (current-buffer))
      (error (message "Invalid expression")
             (insert (current-kill 0)))))

  (defun prelude-recompile-init ()
    "Byte-compile all your dotfiles again."
    (interactive)
    (byte-recompile-directory prelude-dir 0)
    (byte-recompile-directory prelude-vendor-dir 0))

  (defun prelude-regen-autoloads (&optional force-regen)
    "Regenerate the autoload definitions file if necessary and load it."
    (interactive "P")
    (let ((autoload-dir prelude-vendor-dir)
          (generated-autoload-file autoload-file))
      (when (or force-regen
                (not (file-exists-p autoload-file))
                (some (lambda (f) (file-newer-than-file-p f autoload-file))
                      (directory-files autoload-dir t "\\.el$")))
        (message "Updating autoloads...")
        (let (emacs-lisp-mode-hook)
          (update-directory-autoloads autoload-dir))))
    (load autoload-file))

  (defun prelude-sudo-edit (&optional arg)
    (interactive "p")
    (if (or arg (not buffer-file-name))
        (find-file (concat "/sudo:root@localhost:" (ido-read-file-name "File: ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

  (defun prelude-switch-or-start (function buffer)
    "If the buffer is current, bury it, otherwise invoke the function."
    (if (equal (buffer-name (current-buffer)) buffer)
        (bury-buffer)
      (if (get-buffer buffer)
          (switch-to-buffer buffer)
        (funcall function))))

  (defun prelude-insert-date ()
    "Insert a time-stamp according to locale's date and time format."
    (interactive)
    (insert (format-time-string "%c" (current-time))))

  (defun prelude-conditionally-enable-paredit-mode ()
    "Enable paredit-mode in the minibuffer, during eval-expression."
    (if (eq this-command 'eval-expression)
        (paredit-mode 1)))

  (add-hook 'minibuffer-setup-hook 'prelude-conditionally-enable-paredit-mode)

  (defun prelude-recentf-ido-find-file ()
    "Find a recent file using ido."
    (interactive)
    (let ((file (ido-completing-read "Choose recent file: " recentf-list nil t)))
      (when file
        (find-file file))))

  (defun prelude-swap-windows ()
    "If you have 2 windows, it swaps them."
    (interactive)
    (if (/= (count-windows) 2)
        (message "You need exactly 2 windows to do this.")
      (let* ((w1 (first (window-list)))
             (w2 (second (window-list)))
             (b1 (window-buffer w1))
             (b2 (window-buffer w2))
             (s1 (window-start w1))
             (s2 (window-start w2)))
        (set-window-buffer w1 b2)
        (set-window-buffer w2 b1)
        (set-window-start w1 s2)
        (set-window-start w2 s1)))
    (other-window 1))

  (defun prelude-kill-other-buffers ()
    "Kill all buffers but the current one. Doesn't mess with special buffers."
    (interactive)
    (dolist (buffer (buffer-list))
      (unless (or (eql buffer (current-buffer)) (not (buffer-file-name buffer)))
        (kill-buffer buffer))))
   #+END_SRC

* Org Mode
** TODO fill this out




* Slime
    ** fill out

* OSX specific 
handle meta as command
  #+BEGIN_SRC emacs=lisp
(setq mac-command-modifier 'super)
(setq mac-option-modifier 'meta)
  #+END_SRC
use pbcopy.el
  #+BEGIN_SRC emacs=lisp
    (use-package pbcopy
      :ensure
      :config
      (turn-on-pbcopy))

  #+END_SRC
toggle fullscreen
  #+BEGIN_SRC emacs=lisp
(defun toggle-fullscreen ()
  "Toggle full screen"
  (interactive)
  (set-frame-parameter
     nil 'fullscreen
     (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))
  #+END_SRC

* PROGRAMMING
** imenu symbol lookup
This bit of magic binds =M-i= to a function that knows how to identify
functions in the current buffer in many programming languages. Makes
navigating files with many functions quite nice.

This was taken from [[http://batsov.com/prelude/][prelude]] although I had a slightly different
version, perhaps from the emacs-starter-kit prior to that.
#+BEGIN_SRC emacs-lisp
;; Jump to a definition in the current file. (This is awesome.)
(global-set-key (kbd "M-i") 'prelude-ido-goto-symbol)

(require 'imenu)

(set-default 'imenu-auto-rescan t)

(defun prelude-ido-goto-symbol (&optional symbol-list)
  "Refresh imenu and jump to a place in the buffer using Ido."
  (interactive)
  (unless (featurep 'imenu)
    (require 'imenu nil t))
  (cond
   ((not symbol-list)
    (let ((ido-mode ido-mode)
          (ido-enable-flex-matching
           (if (boundp 'ido-enable-flex-matching)
               ido-enable-flex-matching t))
          name-and-pos symbol-names position)
      (unless ido-mode
        (ido-mode 1)
        (setq ido-enable-flex-matching t))
      (while (progn
               (imenu--cleanup)
               (setq imenu--index-alist nil)
               (prelude-ido-goto-symbol (imenu--make-index-alist))
               (setq selected-symbol
                     (ido-completing-read "Symbol? " symbol-names))
               (string= (car imenu--rescan-item) selected-symbol)))
      (unless (and (boundp 'mark-active) mark-active)
        (push-mark nil t nil))
      (setq position (cdr (assoc selected-symbol name-and-pos)))
      (cond
       ((overlayp position)
        (goto-char (overlay-start position)))
       (t
        (goto-char position)))))
   ((listp symbol-list)
    (dolist (symbol symbol-list)
      (let (name position)
        (cond
         ((and (listp symbol) (imenu--subalist-p symbol))
          (prelude-ido-goto-symbol symbol))
         ((listp symbol)
          (setq name (car symbol))
          (setq position (cdr symbol)))
         ((stringp symbol)
          (setq name symbol)
          (setq position
                (get-text-property 1 'org-imenu-marker symbol))))
        (unless (or (null position) (null name)
                    (string= (car imenu--rescan-item) name))
          (add-to-list 'symbol-names name)
          (add-to-list 'name-and-pos (cons name position))))))))
#+END_SRC
** Coding mode config items
   #+BEGIN_SRC emacs-lisp
     (setq lisp-modes '(clojure
                        emacs-lisp
                        lfe
                        scheme)
           code-modes (apply #'append
                             (list lisp-modes
                                   '(erlang
                                     haskell
                                     julia
                                     perl
                                     python
                                     ruby
                                     sh
                                     vhdl))))
     ;; lisp modes
     (defun my-lisp-mode-hook ()
       (font-lock-add-keywords
        nil `(("(\\(lambda\\>\\)"
               (0 (progn (compose-region (match-beginning 1) (match-end 1)
                                         ,(make-char 'greek-iso8859-7 107))
                         nil))))))
     (add-hook-to-modes lisp-modes 'my-lisp-mode-hook)
     (defun my-code-mode-hook ()
       (local-set-key (kbd "C-m") 'newline-and-indent))
     (add-hook-to-modes code-modes 'my-code-mode-hook)
     ;;(add-hook-to-modes code-modes 'my-whitespace-mode-hook)
     ;; paredit - cruise-control for lisp editing
     (defun my-paredit-mode-hook ()
       (show-paren-mode t)
       (paredit-mode t)
       (local-set-key (kbd "C-c (") 'paredit-backward-slurp-sexp)
       (local-set-key (kbd "C-c )") 'paredit-forward-slurp-sexp)
       (local-set-key (kbd "C-c 9") 'paredit-backward-barf-sexp)
       (local-set-key (kbd "C-c 0") 'paredit-forward-barf-sexp))
     (defun after-paredit ()
       (add-hook-to-modes lisp-modes 'my-paredit-mode-hook))
   #+END_SRC
*** C Programming
#+BEGIN_SRC emacs-lisp
(setq-default c-basic-offset 4)
#+END_SRC

* Dealing with text
** No tabs, please.
#+BEGIN_SRC emacs-lisp
(setq-default indent-tabs-mode nil)
#+END_SRC
** Auto-fill (wrap) in text modes.
#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC
** Dealing with and cleanup of whitespace
Helper function for cleaning whitespace from buffers.
#+BEGIN_SRC emacs-lisp
(defun buffer-cleanup ()
  "Clean up the buffer"
  (interactive)
  (delete-blank-lines)
  (delete-trailing-whitespace)
  (untabify (point-min) (point-max))
  (indent-region (point-min) (point-max)))

(global-set-key (kbd "C-c n") 'buffer-cleanup)
#+END_SRC
** Generic aligning of code
Bind a key for aligning code by refexp
#+BEGIN_SRC emacs-lisp
;; Align your code in a pretty way.
(global-set-key (kbd "C-x \\") 'align-regexp)
#+END_SRC
** Magic timestamps? Sure, why not
Make magical timestamps
#+BEGIN_SRC emacs-lisp
;; time-stamps
;; when there's "Time-stamp: <>" in the first 10 lines of the file
(setq time-stamp-active t
      ;; check first 10 buffer lines for Time-stamp: <>
      time-stamp-line-limit 10
      time-stamp-format "%04y-%02m-%02d %02H:%02M %Z") ; date format
(add-hook 'write-file-hooks 'time-stamp) ; update when saving

;; ;; use shift + arrow keys to switch between visible buffers
;; (require 'windmove)
;; (windmove-default-keybindings 'meta)
;; tramp, for sudo access

#+END_SRC
** yasnippet
This is a great snippet/template generator. I should use it, but never
seem to get in the habit of it.
#+BEGIN_SRC emacs-lisp :tangle no
;; load yasnippet
(require 'yasnippet)
(yas/initialize)

(defun yas/advise-indent-function (function-symbol)
  (eval `(defadvice ,function-symbol (around yas/try-expand-first activate)
           ,(format
             "Try to expand a snippet before point, then call `%s' as usual"
             function-symbol)
           (let ((yas/fallback-behavior nil))
             (unless (and (interactive-p)
                          (yas/expand))
               ad-do-it)))))

(yas/advise-indent-function 'noweb-indent-line)
#+END_SRC
** Flyspell
Flyspell provides nice inline spelling correction. Unfortunately, it
makes Emacs very unresponsive for typing which turns out to be mainly
what I want to use Emacs for.
   #+BEGIN_SRC emacs-lisp
      ;; flyspell-mode does spell-checking on the fly as you type
    (setq ispell-program-name "aspell" ; use aspell instead of ispell
          ispell-extra-args '("--sug-mode=ultra"))
    (autoload 'flyspell-mode "flyspell" "On-the-fly spelling checker." t)

    ;; until I can figure out how to make flyspell not be SLOW...
    ;; (defun prelude-turn-on-flyspell ()
    ;;   "Force flyspell-mode on using a positive argument.  For use in hooks."
    ;;   (interactive)
    ;;   (flyspell-mode +1))

    ;; (add-hook 'message-mode-hook 'prelude-turn-on-flyspell)
    ;; (add-hook 'text-mode-hook 'prelude-turn-on-flyspell)
   #+END_SRC
** Expand/complete
This is a very naive completion scheme that works pretty well 80% of
the time.
   #+BEGIN_SRC emacs-lisp
  ;; hippie expand is dabbrev expand on steroids
  (setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                           try-expand-dabbrev-all-buffers
                                           try-expand-dabbrev-from-kill
                                           try-complete-file-name-partially
                                           try-complete-file-name
                                           try-expand-all-abbrevs
                                           try-expand-list
                                           try-expand-line
                                           try-complete-lisp-symbol-partially
                                           try-complete-lisp-symbol))
   #+END_SRC

* Buffers and Files
** ido mode shortcut config: magic file opening and such
This provides a really nice fuzzy matching/search for opening files
and switching buffers.
#+BEGIN_SRC emacs-lisp
(require 'ido)
(ido-mode t)
(setq ido-auto-merge-work-directories-length nil
      ido-create-new-buffer 'always
      ido-enable-flex-matching t
      ido-enable-prefix nil
      ido-handle-duplicate-virtual-buffers 2
      ido-max-prospects 10
      ;; very important to disable this, otherwise, if you happen
      ;; to try to open a file and your cursor happens to be on a
      ;; URL-ish thing, then emacs will hang trying to contact
      ;; some random server for no good reason.
      ido-use-filename-at-point 'nil
      ido-use-virtual-buffers t)
;; auto-completion in minibuffer
(icomplete-mode +1)
#+END_SRC
** Reverting buffer when underlying file changes on disk
This is generally useful especially if you work with git repos and are
changing branches and such.
#+BEGIN_SRC emacs-lisp
(global-auto-revert-mode t)
#+END_SRC
** dired customization
#+BEGIN_SRC emacs-lisp
;; dired - reuse current buffer by pressing 'a'
(put 'dired-find-alternate-file 'disabled nil)
#+END_SRC
** bookmarks: I keep thinking I will use them and never do
#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file (concat user-emacs-directory "bookmarks")
      bookmark-save-flag 1)
#+END_SRC
** Remote editing with tramp
#+BEGIN_SRC emacs-lisp
(require 'tramp)
;; keep in mind known issues with zsh - see emacs wiki
(setq tramp-default-method "ssh")
(add-to-list 'tramp-default-proxies-alist
             '("\\.opscode\\.piab\\'" "\\`root\\'" "/ssh:vagrant@%h:"))
#+END_SRC
** Backup and autosave files get out of my way, please.
By default, emacs writes a backup file next to the file being editing
with a trailing =~= turd.
#+BEGIN_SRC emacs-lisp
;; store all autosave files in the tmp dir
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))

;; backups in backup dir
(setq backup-by-copying t
      backup-directory-alist '(("." . "~/.emacs.d/backup"))
      delete-old-versions t
      kept-new-versions 24
      kept-old-versions 12
      version-control t)

(setq create-lockfiles nil)
#+END_SRC

** Buffer naming, place saving, recent files, and minibuffer details
*** Generate unique buffer names if you open many files with same basename
#+BEGIN_SRC emacs-lisp
(require 'uniquify)
(setq uniquify-buffer-name-style 'forward)
(setq uniquify-separator "/")
(setq uniquify-after-kill-buffer-p t)    ; rename after killing uniquified
(setq uniquify-ignore-buffers-re "^\\*") ; don't muck with special buffers
#+END_SRC
*** Remember my place in files across sessions
#+BEGIN_SRC emacs-lisp
;; saveplace remembers your location in a file when saving files
(setq save-place-file (concat user-emacs-directory "saveplace"))
;; activate it for all buffers
(setq-default save-place t)
(require 'saveplace)
#+END_SRC
*** Remember some history
#+BEGIN_SRC emacs-lisp
;; savehist keeps track of some history
(setq savehist-additional-variables
      ;; search entries
      '(search ring regexp-search-ring)
      ;; save every minute
      savehist-autosave-interval 60
      ;; keep the home clean
      savehist-file (concat user-emacs-directory "savehist"))
(savehist-mode t)
#+END_SRC
*** Remember recent files
#+BEGIN_SRC emacs-lisp
;; save recent files
(setq recentf-save-file (concat user-emacs-directory "recentf")
      recentf-max-saved-items 200
      recentf-max-menu-items 15)
(recentf-mode t)
#+END_SRC

* UI
** inital frame size
   use odd numbers
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(height . 51 )) 
(add-to-list 'default-frame-alist '(width . 181 )) 
#+END_SRC
** tool bars, menu bars, and pop ups
#+BEGIN_SRC emacs-lisp
(dolist (mode '(menu-bar-mode tool-bar-mode scroll-bar-mode))
  (when (fboundp mode) (funcall mode -1)))
#+END_SRC
** cursor and startup screen
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode -1)
;; disable startup screen
(setq inhibit-startup-screen t)
#+END_SRC
** Asking questions
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
(setq use-dialog-box nil)
#+END_SRC
** Making noise (or not)
#+BEGIN_SRC  emacs-lisp
(setq ring-bell-function (lambda () (message "*beep*")))
#+END_SRC
** narrow-to-region
   this is what i'm trying to learn.  C-x n p to narrow and
C-x n w to widen to a page (delineated by ^L chars)
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-page 'disabled nil)
#+END_SRC 
** scrolling
Here are some tweaks for how scrolling behaves. Adjusted values set in
emacs-prelude which sets =scroll-conservatively= to 10000. I think I
like the default better where you get recentering in more cases.
#+BEGIN_SRC emacs-lisp
;(setq scroll-margin 0
;      scroll-conservatively 0
;      scroll-preserve-screen-position 1)
#+END_SRC
** Mode line defaults
#+BEGIN_SRC emacs-lisp
(line-number-mode t)
(column-number-mode t)
(size-indication-mode t)
#+END_SRC
** Font
#+BEGIN_SRC emacs-lisp
;(set-face-attribute 'default nil
;                    :family "Inconsolata"
;                    :height 225
;                    :weight 'normal)
;
#+END_SRC
** FIXME: Color theme selection, line and paren highlighting
#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
  (setq show-paren-style 'parenthesis)
  (global-hl-line-mode -1)
#+END_SRC


#+TITLE: My Special Emacs Configuration
#+AUTHOR: logan mohseni
#+EMAIL: mohsenil85@gmail.com 
#+OPTIONS: toc:3 num:nil ^:nil

I used `brew cask install emacs-mac` to get this version of emacs
* Packages
*** Configure package archives
Use MELPA and the org archives. Put them first to avoid installed gnu
packages if there are newer ones from melpa available.

If we have a net connection, we'll refresh the package list on
startup.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
	       '("melpa" . "http://melpa.milkbox.net/packages/"))

  (add-to-list 'package-archives
	       '("org" . "http://orgmode.org/elpa/"))

  (setq my-onlinep nil)
  (unless
      (condition-case nil
	  (delete-process
	   (make-network-process
	    :name "my-check-internet"
	    :host "melpa.milkbox.net"
	    :service 80))
	(error t))
    (setq my-onlinep t))

(package-initialize)
;  (when my-onlinep
;    (package-refresh-contents)
;    (package-initialize))
#+END_SRC
*** Setup use-package
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/vendor/use-package")
  (require 'use-package)
#+END_SRC
    
** Misc packages
   #+BEGIN_SRC emacs-lisp
(use-package ag :ensure)
(use-package markdown-mode :ensure)
   #+END_SRC
   
*** page break lines
    #+BEGIN_SRC emacs-lisp
    (use-package page-break-lines
      :ensure
      :config
      (global-page-break-lines-mode))
    #+END_SRC
    
*** magit
    #+BEGIN_SRC emacs-lisp
(use-package magit :ensure
:bind ("C-x g" . magit-status))
    #+END_SRC
*** persistent scratch
    #+BEGIN_SRC emacs-lisp
(use-package persistent-scratch :ensure
:config (persistent-scratch-setup-default))
    #+END_SRC
    
* evil 
** evil-leader
   evil leader is required before evil
    #+BEGIN_SRC emacs-lisp
(use-package evil-leader
:ensure
:config
(progn
(global-evil-leader-mode 1)
(evil-leader/set-leader ",")))
    #+END_SRC
** main evil
    #+BEGIN_SRC emacs-lisp
    (use-package evil
      :ensure
      :config
      (evil-mode 1))
    #+END_SRC
* helm
  taken from http://tuhdo.github.io/helm-intro.html
** things i need to remember
- C-h f, which runs describe-function
- C-h v, which runs describe-variable
- C-h w, which runs where-is
** helm proper
    #+BEGIN_SRC emacs-lisp
(use-package helm
:ensure
:demand
:config
(require 'helm)
(require 'helm-config)
(setq helm-M-x-fuzzy-match t)
(setq helm-split-window-inside-p t)
(setq helm-ff-file-name-history-use-recentf t)
(setq helm-autoresize-mode t)

(helm-mode 1)
:bind (
("M-x" . helm-M-x)
("C-c h" . helm-command-prefix)
("C-x b" . helm-mini)
("M-y" . helm-show-kill-ring)
("C-x C-f" . helm-find-files)
("C-c h o" . helm-occur)
 )
)
    #+END_SRC

** helm-projectile
   #+BEGIN_SRC emacs-lisp
   #+END_SRC
* yasnippets everywere 
* org-mode 
    Since use-package detects the version of org that comes with Emacs, I
    ended up running an install from MELPA manually. I've also cloned the
    org git repo into the vendor dir to have access to the contribs.
    #+BEGIN_SRC emacs-lisp
(use-package org
  :ensure
  :mode ("\\.org$" . org-mode)
  :load-path "~/.emacs.d/vendor/org-mode/contrib/lisp"
  :bind (("C-c l" . org-store-link)
	 ("C-c a" . org-agenda)
	 ("C-c b" . org-iswitchb))
  :init
  (setq
   org-directory "~/org"
   org-mobile-inbox-for-pull "~/org/from-mobile.org"
   org-mobile-directory "~/Dropbox/MobileOrg"
   org-agenda-files (quote ("~/org/logan.org"))
   org-enforce-todo-dependencies t
   org-velocity-bucket "~/org/solutions.org"
   org-default-notes-file (concat org-directory "/notes.org")
   org-log-done t
   ;; this prevents org-mode from adding leading whitespace to code
   ;; blocks after editing
   org-src-preserve-indentation t)
  
  ;; where to refile
  (setq org-refile-targets
	'((nil . (:level . 1))
	  ("solutions.org" . (:level . 1))
	  ("seth.org" . (:level . 1))
	  ("seth-sometime.org" . (:level . 1))
	  ("seth-ref.org" . (:level . 1))))
  
  (setq org-refile-use-outline-path 'file)
  )

(use-package org-velocity
  :bind (("C-c 0" . org-velocity-read))
  )

(defun my/org-capture ()
  (interactive)
  (org-capture nil "j"))

(defun my/one-on-one ()
    (interactive)
    (with-temp-buffer
      (setq default-directory "~/Notebook/org/1:1")
      (call-interactively 'ido-find-file)
      (setq current-one-on-one (buffer-file-name))
      (org-capture nil "x")))

(defun my/meeting ()
    (interactive)
    (with-temp-buffer
      (setq default-directory "~/Notebook/org/meetings")
      (call-interactively 'ido-find-file)
      (setq current-one-on-one (buffer-file-name))
      (org-capture nil "m")))

(use-package org-capture
  :bind (("C-c 1" . my/org-capture)
	 ("C-c 2" . my/one-on-one)
	 ("C-c 3" . org-capture)
	 ("C-c 4" . my/meeting)
	 )
  :init
  (setq
   ;; capture setup
   org-capture-templates
   '(("t" "Todo" entry
      (file+headline (concat org-directory "/seth.org") "Next Action")
      "* TODO %?\n  %i\n  %a")
     ("s" "Solution" entry
      (file+headline (concat org-directory "/solutions.org"))
      "* %?\nEntered on %U\n  %i\n  %a")
     ("j" "Journal" entry
      (file (concat org-directory "/journal.org"))
      "* [%<%d-%b-%Y %H:%M>] %?\n%i\n")
     ("z" "Testing" entry
      (file (concat org-directory "/test-cap.org"))
      "* [%<%d-%b-%Y %H:%M>] %?\n%i\n")
     ("x" "1:1 Note" entry
      (file current-one-on-one)
      "* [%<%d-%b-%Y %H:%M>] %?\n%i\n" :prepend t :unnarrowed t)
     ("m" "Meeting Notes" entry
      (file current-meeting)
      "* [%<%d-%b-%Y %H:%M>] %?\n** Attendees\n** Notes%i\n" :prepend t :unnarrowed t)
     ("f" "Journal with file link" entry
      (file+datetree (concat org-directory "/journal.org"))
      "* [%<%H:%M>] %?\n%i\n%a\n")
     )
   )
  )

    #+END_SRC
    

* Defuns
Helper functions to use either in an editing session or to help with
configuration
#+BEGIN_SRC emacs-lisp
(require 'cl)

(defun save-init-org ()
(org-babel-load-file
 (expand-file-name "emacs-init.org"
		   user-emacs-directory)))

(defun add-hook-to-modes (modes hook)
  (dolist (mode modes)
    (add-hook (intern (concat (symbol-name mode) "-mode-hook"))
	      hook)))

(defun halt ()
  (interactive)
  (save-some-buffers)
  (kill-emacs))

(defun my-whitespace-mode-hook ()
  (setq whitespace-action '(auto-cleanup)
	whitespace-style  '(face tabs trailing lines-tail empty)
	;; use fill-column value instead
	whitespace-line-column nil)
  (whitespace-mode))

(defun my-makefile-mode-hook ()
  (setq indent-tabs-mode t
	tab-width 4))
#+END_SRC
** Prelude defuns and such
   #+BEGIN_SRC emacs-lisp
  ;;; prelude-core.el --- Emacs Prelude: core Prelude defuns.
  ;;
  ;; Copyright (c) 2011 Bozhidar Batsov
  ;;
  ;; Author: Bozhidar Batsov <bozhidar.batsov@gmail.com>
  ;; URL: http://www.emacswiki.org/cgi-bin/wiki/Prelude
  ;; Version: 1.0.0
  ;; Keywords: convenience

  ;; This file is not part of GNU Emacs.

  ;;; Commentary:

  ;; Here are the definitions of most of the functions added by Prelude.

  ;;; License:

  ;; This program is free software; you can redistribute it and/or
  ;; modify it under the terms of the GNU General Public License
  ;; as published by the Free Software Foundation; either version 3
  ;; of the License, or (at your option) any later version.
  ;;
  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.
  ;;
  ;; You should have received a copy of the GNU General Public License
  ;; along with GNU Emacs; see the file COPYING.  If not, write to the
  ;; Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  ;; Boston, MA 02110-1301, USA.

  ;;; Code:

  (require 'thingatpt)

  (defun prelude-open-with ()
    "Simple function that allows us to open the underlying
  file of a buffer in an external program."
    (interactive)
    (when buffer-file-name
      (shell-command (concat
		      (if (eq system-type 'darwin)
			  "open"
			(read-shell-command "Open current file with: "))
		      " "
		      buffer-file-name))))

  (defun prelude-buffer-mode (buffer-or-name)
    (with-current-buffer buffer-or-name major-mode))

  (defun prelude-visit-term-buffer ()
    (interactive)
    (if (not (get-buffer "*ansi-term*"))
	(ansi-term "/bin/bash")
      (switch-to-buffer "*ansi-term*")))

  (defun prelude-google ()
    "Googles a query or region if any."
    (interactive)
    (browse-url
     (concat
      "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
      (if mark-active
	  (buffer-substring (region-beginning) (region-end))
	(read-string "Google: ")))))

  (defun prelude-indent-rigidly-and-copy-to-clipboard (begin end indent)
    "Copy the selected code region to the clipboard, indented according
  to Markdown blockquote rules."
    (let ((buffer (current-buffer)))
      (with-temp-buffer
	(insert-buffer-substring-no-properties buffer begin end)
	(indent-rigidly (point-min) (point-max) indent)
	(clipboard-kill-ring-save (point-min) (point-max)))))

  (defun prelude-indent-blockquote-and-copy-to-clipboard (begin end)
    "Copy the selected code region to the clipboard, indented according
  to markdown blockquote rules (useful to copy snippets to StackOverflow, Assembla, Github."
    (interactive "r")
    (prelude-indent-rigidly-and-copy-to-clipboard begin end 4))

  (defun prelude-indent-nested-blockquote-and-copy-to-clipboard (begin end)
    "Copy the selected code region to the clipboard, indented according
  to markdown blockquote rules. Useful to add snippets under bullet points."
    (interactive "r")
    (prelude-indent-rigidly-and-copy-to-clipboard begin end 6))

  (defun prelude-insert-empty-line ()
    "Insert an empty line after the current line and positon
  the curson at its beginning, according to the current mode."
    (interactive)
    (move-end-of-line nil)
    (open-line 1)
    (next-line 1)
    (indent-according-to-mode))

  ;; mimic popular IDEs binding, note that it doesn't work in a terminal session
  (global-set-key [(shift return)] 'prelude-insert-empty-line)

  (defun prelude-move-line-up ()
    "Move up the current line."
    (interactive)
    (transpose-lines 1)
    (previous-line 2))

  (global-set-key [(control shift up)] 'prelude-move-line-up)

  (defun prelude-move-line-down ()
    "Move down the current line."
    (interactive)
    (next-line 1)
    (transpose-lines 1)
    (previous-line 1))

  (global-set-key [(control shift down)] 'prelude-move-line-down)

  ;; add the ability to copy and cut the current line, without marking it
  (defadvice kill-ring-save (before slick-copy activate compile)
    "When called interactively with no active region, copy a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (message "Copied line")
       (list (line-beginning-position)
	     (line-beginning-position 2)))))

  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
	     (line-beginning-position 2)))))

  (defun prelude-indent-buffer ()
    "Indents the entire buffer."
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun prelude-indent-region-or-buffer ()
    "Indents a region if selected, otherwise the whole buffer."
    (interactive)
    (save-excursion
      (if (region-active-p)
	  (progn
	    (indent-region (region-beginning) (region-end))
	    (message "Indented selected region."))
	(progn
	  (prelude-indent-buffer)
	  (message "Indented buffer.")))))

  (defun prelude-annotate-todo ()
    "Put fringe marker on TODO: lines in the curent buffer."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "TODO:" nil t)
	(let ((overlay (make-overlay (- (point) 5) (point))))
	  (overlay-put overlay
		       'before-string
		       (propertize (format "A")
				   'display '(left-fringe right-triangle)))))))

  (defun prelude-copy-file-name-to-clipboard ()
    "Put the current file name on the clipboard."
    (interactive)
    (let ((filename (if (equal major-mode 'dired-mode)
			default-directory
		      (buffer-file-name))))
      (when filename
	(with-temp-buffer
	  (insert filename)
	  (clipboard-kill-region (point-min) (point-max)))
	(message filename))))

  (defun prelude-duplicate-current-line-or-region (arg)
    "Duplicates the current line or region ARG times.
  If there's no region, the current line will be duplicated. However, if
  there's a region, all lines that region covers will be duplicated."
    (interactive "p")
    (let (beg end (origin (point)))
      (if (and mark-active (> (point) (mark)))
	  (exchange-point-and-mark))
      (setq beg (line-beginning-position))
      (if mark-active
	  (exchange-point-and-mark))
      (setq end (line-end-position))
      (let ((region (buffer-substring-no-properties beg end)))
	(dotimes (i arg)
	  (goto-char end)
	  (newline)
	  (insert region)
	  (setq end (point)))
	(goto-char (+ origin (* (length region) arg) arg)))))

  ;; TODO doesn't work with uniquify
  (defun prelude-rename-file-and-buffer ()
    "Renames current buffer and file it is visiting."
    (interactive)
    (let ((name (buffer-name))
	  (filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
	  (message "Buffer '%s' is not visiting a file!" name)
	(let ((new-name (read-file-name "New name: " filename)))
	  (cond ((get-buffer new-name)
		 (message "A buffer named '%s' already exists!" new-name))
		(t
		 (rename-file name new-name 1)
		 (rename-buffer new-name)
		 (set-visited-file-name new-name)
		 (set-buffer-modified-p nil)))))))

  (defun prelude-delete-file-and-buffer ()
    "Kills the current buffer and deletes the file it is visiting"
    (interactive)
    (let ((filename (buffer-file-name)))
      (when filename
	(delete-file filename)
	(message "Deleted file %s" filename)))
    (kill-buffer))

  (defun prelude-view-url ()
    "Open a new buffer containing the contents of URL."
    (interactive)
    (let* ((default (thing-at-point-url-at-point))
	   (url (read-from-minibuffer "URL: " default)))
      (switch-to-buffer (url-retrieve-synchronously url))
      (rename-buffer url t)
      ;; TODO: switch to nxml/nxhtml mode
      (cond ((search-forward "<?xml" nil t) (xml-mode))
	    ((search-forward "<html" nil t) (html-mode)))))

  ;; We have a number of turn-on-* functions since it's advised that lambda
  ;; functions not go in hooks. Repeatedly evaluating an add-to-list with a
  ;; hook value will repeatedly add it since there's no way to ensure
  ;; that a lambda doesn't already exist in the list.

  (defun prelude-turn-on-whitespace ()
    (whitespace-mode +1))

  (defun prelude-turn-off-whitespace ()
    (whitespace-mode -1))

  (defun prelude-turn-on-abbrev ()
    (abbrev-mode +1))

  (defun prelude-turn-off-abbrev ()
    (abbrev-mode -1))

  (defun prelude-untabify-buffer ()
    (interactive)
    (untabify (point-min) (point-max)))

  (defun prelude-cleanup-buffer ()
    "Perform a bunch of operations on the whitespace content of a buffer."
    (interactive)
    (prelude-indent-buffer)
    (prelude-untabify-buffer)
    (whitespace-cleanup))

  (defun prelude-eval-and-replace ()
    "Replace the preceding sexp with its value."
    (interactive)
    (backward-kill-sexp)
    (condition-case nil
	(prin1 (eval (read (current-kill 0)))
	       (current-buffer))
      (error (message "Invalid expression")
	     (insert (current-kill 0)))))

  (defun prelude-recompile-init ()
    "Byte-compile all your dotfiles again."
    (interactive)
    (byte-recompile-directory prelude-dir 0)
    (byte-recompile-directory prelude-vendor-dir 0))

  (defun prelude-regen-autoloads (&optional force-regen)
    "Regenerate the autoload definitions file if necessary and load it."
    (interactive "P")
    (let ((autoload-dir prelude-vendor-dir)
	  (generated-autoload-file autoload-file))
      (when (or force-regen
		(not (file-exists-p autoload-file))
		(some (lambda (f) (file-newer-than-file-p f autoload-file))
		      (directory-files autoload-dir t "\\.el$")))
	(message "Updating autoloads...")
	(let (emacs-lisp-mode-hook)
	  (update-directory-autoloads autoload-dir))))
    (load autoload-file))

  (defun prelude-sudo-edit (&optional arg)
    (interactive "p")
    (if (or arg (not buffer-file-name))
	(find-file (concat "/sudo:root@localhost:" (ido-read-file-name "File: ")))
      (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

  (defun prelude-switch-or-start (function buffer)
    "If the buffer is current, bury it, otherwise invoke the function."
    (if (equal (buffer-name (current-buffer)) buffer)
	(bury-buffer)
      (if (get-buffer buffer)
	  (switch-to-buffer buffer)
	(funcall function))))

  (defun prelude-insert-date ()
    "Insert a time-stamp according to locale's date and time format."
    (interactive)
    (insert (format-time-string "%c" (current-time))))

  (defun prelude-conditionally-enable-paredit-mode ()
    "Enable paredit-mode in the minibuffer, during eval-expression."
    (if (eq this-command 'eval-expression)
	(paredit-mode 1)))

  (add-hook 'minibuffer-setup-hook 'prelude-conditionally-enable-paredit-mode)

  (defun prelude-recentf-ido-find-file ()
    "Find a recent file using ido."
    (interactive)
    (let ((file (ido-completing-read "Choose recent file: " recentf-list nil t)))
      (when file
	(find-file file))))

  (defun prelude-swap-windows ()
    "If you have 2 windows, it swaps them."
    (interactive)
    (if (/= (count-windows) 2)
	(message "You need exactly 2 windows to do this.")
      (let* ((w1 (first (window-list)))
	     (w2 (second (window-list)))
	     (b1 (window-buffer w1))
	     (b2 (window-buffer w2))
	     (s1 (window-start w1))
	     (s2 (window-start w2)))
	(set-window-buffer w1 b2)
	(set-window-buffer w2 b1)
	(set-window-start w1 s2)
	(set-window-start w2 s1)))
    (other-window 1))

  (defun prelude-kill-other-buffers ()
    "Kill all buffers but the current one. Doesn't mess with special buffers."
    (interactive)
    (dolist (buffer (buffer-list))
      (unless (or (eql buffer (current-buffer)) (not (buffer-file-name buffer)))
	(kill-buffer buffer))))
   #+END_SRC

* Slime
;;(use-package paredit :ensure)
    ** fill out

* OSX specific 
handle meta as command
  #+BEGIN_SRC emacs=lisp
(setq mac-command-modifier 'super)
(setq mac-option-modifier 'meta)
  #+END_SRC
use pbcopy.el
  #+BEGIN_SRC emacs=lisp
    (use-package pbcopy
      :ensure
      :config
      (turn-on-pbcopy))

  #+END_SRC
toggle fullscreen
  #+BEGIN_SRC emacs=lisp
(defun toggle-fullscreen ()
  "Toggle full screen"
  (interactive)
  (set-frame-parameter
     nil 'fullscreen
     (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))
  #+END_SRC

* Emacs
** inital frame size
   use odd numbers
#+BEGIN_SRC emacs-lisp
(add-to-list 'default-frame-alist '(height . 51 )) 
(add-to-list 'default-frame-alist '(width . 181 )) 
#+END_SRC
** tool bars, menu bars, and pop ups
#+BEGIN_SRC emacs-lisp
(dolist (mode '(menu-bar-mode tool-bar-mode scroll-bar-mode))
  (when (fboundp mode) (funcall mode -1)))
#+END_SRC
** cursor and startup screen
#+BEGIN_SRC emacs-lisp
(blink-cursor-mode -1)
;; disable startup screen
(setq inhibit-startup-screen t)
#+END_SRC
** Asking questions
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
(setq use-dialog-box nil)
#+END_SRC
** Making noise (or not)
#+BEGIN_SRC  emacs-lisp
(setq ring-bell-function (lambda () (message "*beep*")))
#+END_SRC
** narrow-to-region
   this is what i'm trying to learn.  C-x n p to narrow and
C-x n w to widen to a page (delineated by ^L chars)
#+BEGIN_SRC emacs-lisp
(put 'narrow-to-page 'disabled nil)
#+END_SRC 
** scrolling
Here are some tweaks for how scrolling behaves. Adjusted values set in
emacs-prelude which sets =scroll-conservatively= to 10000. I think I
like the default better where you get recentering in more cases.
#+BEGIN_SRC emacs-lisp
;(setq scroll-margin 0
;      scroll-conservatively 0
;      scroll-preserve-screen-position 1)
#+END_SRC
** Mode line defaults
#+BEGIN_SRC emacs-lisp
(line-number-mode t)
(column-number-mode t)
(size-indication-mode t)
#+END_SRC
** Font
#+BEGIN_SRC emacs-lisp
;(set-face-attribute 'default nil
;                    :family "Inconsolata"
;                    :height 225
;                    :weight 'normal)
;
#+END_SRC
** FIXME: Color theme selection, line and paren highlighting
#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
  (setq show-paren-style 'parenthesis)
  (global-hl-line-mode -1)
#+END_SRC

** color theme
   #+BEGIN_SRC emacs-lisp
   (use-package gandalf-theme :ensure)
   (load-theme 'gandalf)

   #+END_SRC
** registers
#+BEGIN_SRC emacs-lisp
(set-register ?e (cons 'file "~/.emacs.d/emacs-init.org"))
#+END_SRC
